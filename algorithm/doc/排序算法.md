- 经典十大排序算法：
> 插入排序法，希尔排序法，选择排序法，堆排序法，冒泡排序，快速排序，归并排序，计数排序，桶排序，基数排序。
1. 排序算法分两大类：
    1. 非线性时间比较类排序：
    > 通过比较来决定元素间的相对次序，由于时间复杂度不能突破O(nlogn),因此称为非线性比较类排序；
    
    2. 线性时间非比较类排序：
    > 不通过比较来决定元素间的相对次序，他可以突破基于比较的时间下界，以线性时间运行，因此称为线性时间非比较类排序。

![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20180402132530342-980121409.png)

2. 算法复杂度
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20180402133438219-1946132192.png)

> 1. 稳定：如果a原本在b前面，当a=b,排序后a还是在b的前面；
> 2. 不稳定：如果a原本在b前面，当a=b,排序后a可能在b的后面；


- 冒泡排序
> 冒泡排序是一种简单的排序算法，重复比较相邻的元素大小，如果顺序错误就置换顺序，直到重复进行到没有可以置换就说明已经完成排序了。
1. 演示动画：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015223238449-2146169197.gif)


2. 代码实例：

```
public function bubbleSort($arr) {
    for($i = 0; $i < count($arr) - 1; $i++) {
        for($j = 0; $j < count($arr) - $i - 1; $j++) {
            if($arr[$j] > $arr[$j+1]) {
                $temp = $arr[$j+1];
                $arr[$j+1] = $arr[$j];
                $arr[$j] = $tmep;
            }
        }
    }
    
    return $arr;
}
```
> 冒泡排序需要两层循环遍历数组，因此时间复杂度是O(n^2);


- 选择排序
> 选择排序是一种简单直观的排序算法，首先从数列中找到最小或者最大的放在起始位置。再继续从剩下的数组找出最小或者最大的放在最小的后面，直到所有元素排序完成。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015224719590-1433219824.gif)
> 选择排序是一种罪稳定的排序算法，无论怎么顺序的数列的排序时间复杂度都是O(n^2)。不用占用额外的内存空间。

2. 代码实例：

```
public function selectionSort($arr) {
    for($i = 0; $i < count($arr) - 1; $i++) {
        $minIndex = $i;
        for($j = $i + 1; $j < count($arr); $j++) {
            if($arr[$j] < $arr[$minIndex]) {
                $minIndex = $j;
            }
        }
        
        $temp = $arr[$i];
        $arr[$i] = $arr[$minIndex];
        $arr[$minIndex] = $arr[$i];
    }
}
```


- 插入排序
>  从起始位置开始用后面元素依次比较前面已经有序的元素插入正确顺序构成有序，一次到数列的最后一个元素完成排序。

1. 动图演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015225645277-1151100000-1.gif)
> 1. 首先用起始位置元素跟后面元素比较大小排序形成有序；
> 2. 再用后面元素依次比较插入到有序序列中；
> 3. 依次类推到最后一个元素完成排序。

2. 代码实例：

```
public function insertionSort($arr){
    for($i = 1; $i < count($arr); $i++) {
        $preIndex = $i - 1;
        $current = $arr[$i];
        while($preIndex >= 0 && $arr[$preIndex] > $current) {
            $arr[$preIndex + 1] = $arr[$preIndex];
            $preIndex --;
        }
        
        $arr[$preIndex + 1] = $current;
    }
    
    return $arr;
}
```


- 希尔排序
> 是升级版的插入排序，是优先取距离远的元素间隔比较后再进行插入排序。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20180331170017421-364506073.gif)
> 1. 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
> 2. 按增量序列个数k，对序列进行k 趟排序；
> 3. 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
2. 代码实例：

```
function shellSort($arr){
    $gap = 1;
    while($gap < count($arr) /3) {
        $gap = $gap * 3 +1;
    }
    for($gap; $gap > 0; $gap = floor($gap / 3)) {
        for( $i = $gap; $i < count($arr); $i++) {
            $temp = $arr[$i];
            for($j = $i - $gap; $j >= 0 && $arr[$j] > $temp; $j-= $gap) {
                $arr[$j + $gap] = $arr[$j];
            }
        
            $arr[$j + $gap] = $temp;
        }
    }
    
    return $arr;
}
```


- 归并排序
> 归并排序是建立在归并操作上的一种有效排序算法，他是采用分治法。将已有序的子序列合并等待完整有序序列。如将两个有序表合并成一个有序表称为2-路归并。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015230557043-37375010.gif)
> 1. 把长度为n的输入序列分成两个长度为n/2的子序列；
> 2. 对这两个字序列分别采用归并排序；
> 3. 将两个排序好的子序列合并成一个最终的排序序列；

2. 代码实例：

```
function mergeSort($arr) {
    if(count($arr) < 2) {
        return $arr;
    }
    $left = array_slice($arr, 0, floor(count($arr) / 2));
    $right = array_slice($arr, floor(count($arr) / 2));
    return merge(mergeSort($left), mergeSort($right));
}
function merge($left, $right)
{
    $result = [];
    
    while(count($left) > 0 && count($right) > 0) {
        if($left[0] <= $right[0]) {
            array_push($result, array_shift($left));
        }else{
            array_push($result, array_shift($right));
        }
    }
    
    while(count($left)) {
        array_push($result, array_shift($left));
    }
    
    while(count($right)) {
        array_push($result, array_shift($right));
    }
    
    return $result;
}
```
> 归并排序也是一个很稳定的算法，时间复杂度始终都是O(nlogn)。只是需要更多内存空间。


- 快速排序
> 一个元素为“基准”，通过一次排序分隔两个部分，再分别对两个部分进行同样的分隔操作，直到分隔两部分只有一个元素即完成排序；

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015230936371-1413523412.gif)

2. 代码实例：

```
function quickSort($arr) {
    if(count($arr) < 2) {
        return $arr;
    }
    $left = [];
    $right = [];
    for ($i = 1; $i < count($arr); $i++) {
        if($arr[$i] > $arr[0]) {
            $right[] = $arr[$i];
        }else{
            $left[] = $arr[$i];
        }
    }
    
    $left = quickSort($left);
    $right = quickSort($right);
    
    return array_merge($left, [$arr[0]], $right);
}
```


- 堆排序
> 堆排序是利用堆的数据结构（类似完全二叉树）的排序算法，首先得到最大置顶的堆，然后循环将最大放在尾元素，顶部元素再循环倒数第二个元素找出最大元素置顶，依次缩小范围查找最大值。最后就完成排序。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015231308699-356134237.gif)

> 1. 将初始待排序关键字序列(R1,R2….Rn)构建成大顶堆，此堆为初始的无序区；
> 2. 将堆顶元素R[1]与最后一个元素R[n]交换，此时得到新的无序区(R1,R2,……Rn-1)和新的有序区(Rn),且满足R[1,2…n-1]<=R[n]；
> 3. 由于交换后新的堆顶R[1]可能违反堆的性质，因此需要对当前无序区(R1,R2,……Rn-1)调整为新堆，然后再次将R[1]与无序区最后一个元素交换，得到新的无序区(R1,R2….Rn-2)和新的有序区(Rn-1,Rn)。不断重复此过程直到有序区的元素个数为n-1，则整个排序过程完成。

2. 代码实例：

```
function heapSort($arr) {
    $len = count($arr);
    for($i = $len / 2 -1;$i >= 0; $i--) {
        maxHeapify($arr, $i, $len);
    }
    
    for($i = $len - 1; $i > 0; $i--) {
        $temp = $arr[$i];
        $arr[$i] = $arr[0];
        $arr[0] = $temp;
        
        maxHeapify($arr, 0, $i);
    }
    
    return $arr;
}
function maxHeapify(&$arr, $start, $end) {
    $parent = $start;
    $child = $parent * 2 + 1;
    if($child >= $end) {
        return;
    }
    
    if($child + 1 < $parent && $arr[$child] < $arr[$child + 1]) {
        $child ++;
    }
    
    if($arr[$parent] <= $arr[$child]) {
        $temp = $arr[$child];
        $arr[$child] = $arr[$parent];
        $arr[$parent] = $temp;
        
        maxHeapify($arr, $child, $end);
    }
}
```

- 计数排序
> 计数排序是一种不基于比较的排序算法，其思想是从数列中最小和最大数字的连续大小数字统计每个数字出现的次数，然后根据数字的次数构成有序的数列。是一种线性的时间复杂度的排序算法，从最小数0到最大数k的的时间复杂度是O(n+k)。也就是这个算法的优劣取决于最大值和最小的跨度，对于跨度的数列排序是一个很高效的排序算法。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015231740840-6968181.gif)


2. 代码实例：

```
function countingSort($arr) {
    if(count($arr) < 2) {
        return $arr;
    }
    $min = min($arr);
    $max = max($arr);
    if($min >= $max) {
        return $arr;
    }
    $bucket = array_fill_keys(range($min, $max), 0);
    foreach ($arr as $value) {
        if(isset($bucket[$value])) {
            $bucket[$value] ++;
        }
    }
    
    $sortIndex = 0;
    foreach($bucket as $key => $value) {
        while($value) {
            $arr[$sortIndex++] = $key;
            $value--;
        }
    }
    
    return $arr;
}
```


- 桶排序
> 桶排序是一种计数排序的升级版，将均匀映射分布到有限数据的桶里面，然后再对不是空的桶进行排序，最后将桶按照顺序拼接起来就完成排序。

1. 代码实例：

```
function bucketSort($arr, $bucketCount = 5) {
    if(count($arr) < 2 || $bucketCount < 1) {
        return $arr;
    }
    $min = min($arr);
    $max = max($arr);
    if($min >= $max) {
        return $arr;
    }
    $space = ($max - $min + 1) / $bucketCount;
    $buckets = [];
    foreach($arr as $key => $value) {
        $index = floor(($value - $min) / $space);
        if(isset($buckets[$index])) {
            $k = count($buckets[$index]) - 1;
            while( $k >= 0 && $buckets[$index][$k] > $value) {
                $buckets[$index][$k + 1] = $buckets[$index][$k];
                $k--;
            }
            $buckets[$index][$k + 1] = $value;
        }else {
            $buckets[$index] = [];
            $buckets[$index][] = $value;
        }
    }
    
    
    $i = 0;
    $data = [];
    while($i < $bucketCount) {
        if($buckets[$i]) {
            $data = array_merge($data, $buckets[$i]);
        }
        
        $i++;
    }
    
    return $data;
}
```


- 基数排序
> 基数排序也是一种升级版的桶排序，基本思想是先从低位到高位进行桶排序。

1. 动画演示：
![image](http://www.gavin.xin/wp-content/uploads/2018/10/849589-20171015232453668-1397662527.gif)

2. 代码实例：

```
function radixSort($arr) {
    $len = count($arr);
    if($len < 2) {
        return $arr;
    }
    
    $max = max($arr);
    $loop = 1;
    while($max >= 10) {
        $loop ++;
        $max = floor($max / 10);
    }

    for($i = 1; $i <= $loop; $i++){
        $dev = intval(pow(10, $i - 1));
        $mod = 10;
        $counter = array_fill_keys(range(0, 9), []);
        for($j = 0; $j < $len; $j++) {
            $bucket = floor(($arr[$j] / $dev) % $mod);
            array_push($counter[$bucket], $arr[$j]);
        }
        
        $pos = 0;
        for($k = 0; $k < 10; $k++) {
            while(count($counter[$k]) > 0) {
                $arr[$pos++] = array_shift($counter[$k]);
            }
        }
    }
    
    return $arr;
}

```


