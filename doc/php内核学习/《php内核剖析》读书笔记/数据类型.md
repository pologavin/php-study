php中通过zval这个结构体表示一个变量，而不同类型的变量值则通过**zval**嵌入的一个联合体表示，即**zend_value**。zval，zend_value及不同类型的结构实现了php基础的数据类型。
1. zval结构体
```
struct _zval_struct {
    // 变量值
	zend_value        value;			/* value */
	// union u1
	union {
		struct {
		   // 宏：用来解决字节序问题
			ZEND_ENDIAN_LOHI_3(
			    // 变量类型
				zend_uchar    type,			/* active type */
				// 类型掩码，各类型会有不同的几种属性，内存管理会用到
				zend_uchar    type_flags,
				union {
					uint16_t  call_info;    /* call info for EX(This) */
					uint16_t  extra;        /* not further specified */
				} u)
		} v;
		uint32_t type_info;
	} u1;
	// union u2 辅助值 系统会进行字节对齐，zend_value和u1分别占8byte和4byte，只有12个字节，对齐16字节多了4byte定义u2做辅助功能。
	union {
		uint32_t     next;                 /* hash collision chain */
		uint32_t     cache_slot;           /* literal cache slot */
		uint32_t     lineno;               /* line number (for ast nodes) */
		uint32_t     num_args;             /* arguments number for EX(This) */
		uint32_t     fe_pos;               /* foreach position */
		uint32_t     fe_iter_idx;          /* foreach iterator index */
		uint32_t     access_flags;         /* class constant access flags */
		uint32_t     property_guard;       /* single property guard */
		uint32_t     extra;                /* not further specified */
	} u2;
};
```

2. zend_value结构体

```

typedef union _zend_value {
	zend_long         lval;				/* long value */
	double            dval;				/* double value */
	zend_refcounted  *counted;
	zend_string      *str;
	zend_array       *arr;
	zend_object      *obj;
	zend_resource    *res;
	zend_reference   *ref;
	zend_ast_ref     *ast;
	zval             *zv;
	void             *ptr;
	zend_class_entry *ce;
	zend_function    *func;
	struct {
		uint32_t w1;
		uint32_t w2;
	} ww;
} zend_value;
```

- 字符串
> 定义一个zend_string的结构体，在zend_value中通过str指向具体的结构，zend_string除了字符串内容，还存储了其他内容。

```
struct _zend_string {
zend_refcounted_h gc; //变量的引用计数，用于内存管理
zend_ulong  h;/* hash value 通过times33算法得到的hash code*/
size_t   len; // 字符串长度
char   val[1];  // 字符串内容
};
```
1. 存储字符串内容是一个可变数组val[1]，在分配内存时会malloc(sizeof(zend_string) + 字符串长度)多分配一点内存。


- 数组
> 底层使用散列表hashTable,这种数据结构使得php数组非常灵活。
1. 散列表
> 通过散列函数将key->value的映射关系控制在一个较为理想非全域的范围内。这样的一个映射关系必定存在冲突问题，通过链表解决这种冲突。所有元素都存放在一个链表结构中。这种链表的设计会存在一种最坏的情况就是左右元素存在一个同一个链表上，所以其中散列映射函数需要考虑尽可能使得元素简单均匀散列。
2. 散列函数

```
nIndex= key->h | nTableSize 
// 或运算
```
3. 数组结构

```
struct _zend_array {
	zend_refcounted_h gc; // 引用计数
	union {
		struct {
			ZEND_ENDIAN_LOHI_4(
				zend_uchar    flags,
				zend_uchar    _unused,
				zend_uchar    nIteratorsCount,
				zend_uchar    consistency)
		} v;
		uint32_t flags;
	} u;
	uint32_t          nTableMask; // 用于散列函数映射存储元素杂arData数组的下标，这个值在散列函数根据key和hash code 映射元素的存储位置是用到，它的实际值是nTableSize 的负数，
	Bucket           *arData; // 存储元素bucket的数组，其内存是连续的，arData指向数组的起始位置。
	uint32_t          nNumUsed; // 已用bucket数
	uint32_t          nNumOfElements; // 数组实际存储的元素数
	uint32_t          nTableSize; // 数组的总容量
	uint32_t          nInternalPointer;
	zend_long         nNextFreeElement;
	dtor_func_t       pDestructor;
};
```

4. 散列表的有序
> 散列函数使得元素随机均匀，为了实现有序性，PHP中的散列表在散列函数和元素数组之间加了一层映射表，这个映射表也是一个数组，大小与存储元素的数组相同，它存储的元素类型为整型，用于保存元素在实际存储的有序数组中的下标：元素按照先后顺序依次插入实际存储数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中(uint32_t nTableMask)。
5. 数组的实现
> 1. 初始化：对HashTable中的成员进行设置，初始化时并没有立即分配arData的内存，而是在插入第一个元素进行内存分配。初始化操作是通过zend_hash_init()宏完成，最后由_zend_hash_init()函数处理。
> 2. 插入：首先检查数组是已经分配存储空间，如果是首次插入先执行分配内容空间。分配完后会把HashTable->u.flags打上HASH_FLAG_INITIALIZED掩码，下次不会重复分配内存操作。接下来插入操作是将元素按照顺序插入arData，然后将其咋arData数组中的位置存储到根据key的hash coce（key->h）与nTableMask计算得到的中间映射表中的对应位置。
> 3. 查找：首先通过key计算出hash code 与nTableMask 计算得到散列值nIndex,然后根据散列值从中间映射表中得到存储元素在有序存储数组中的位置idx，接着根据idx从有序数组中arData取出Bucket，最终从这Bucket中查找key查找key。


- 引用
> 一种特殊的数据类型，本质并不是独立的数据类型，而是指向另一种数据类型的结构。类似c语言的指针概念。当修改引用类型的变量，其修改将反映在实际引用的变量上。
1. 引用结构

```
struct _zend_reference {
	zend_refcounted_h gc;
	zval              val;  // 指向原来的value
};
```
