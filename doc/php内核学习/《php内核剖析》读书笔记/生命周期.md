> php整个生命周期分为五个阶段：模块初始化阶段（module startup）,请求初始化阶段（request startup），执行脚本阶段（execute script），请求关闭阶段（request shutdown），模块关闭阶段（module shutdown）；根据不同的SAPI实现，每个阶段执行有一些差异。
1. 模块初始化阶段
> 主要进行php框架，zend引擎的初始化操作，入口函数是php_module_startup()。这个阶段只在SAPI启动执行一次，对fpm来说，在master进程启动时执行。  

    1. SAPI激活（sapi_activate()）: 初始化SG(request info)，设置读取post请求的handler等。在整个module startup阶段完成后调用sapi_deactivate()结束；
    2. 启动php输出（php_output_startup()）
    3. 初始化垃圾回收器（gc_globals_ctor()）: 分配zend_gc_glodals内存；
    4. 启动zend引擎(zend_startup()) ：
         1. cpuinfo初始化（zend_cpu_startup()）；
         2. 启动内存池（start_memory_manager()）；
         3. 启动cwd指令（virtual_cwd_startup()）；
         4. 设置一些util函数句柄（zend_error_cb,zend_printf,zend_write等）；
         5. 设置zend虚拟机编译，执行器的函数句柄zend_compile_file,zend_execute_ex以及垃圾回收的函数句柄gc_collect_cycles；
         6. 分配函数符号表（CG(function_table)）,类符号（CG(class_table)）,常量符号表（zend_constants）等，如果是多线程的话，还会分配编译器，执行器的全局变量；
         7. 注册zend核心扩展：zend_startup_builtin_functions(),这个扩展是内核提供的，该过程将注册zend可信扩展提供的函数（如strlen，define，func_get_args）;
         8. 注册zend定义的标准常量：zend_register_standard_constants(),（如E_ERROR,TRUE,FALSE）;
         9. 注册$GLOBALS超全局变量的获取handler；
         10. 分配php.ini配置的存储符号表（EG(ini_directives)）;
     5. 注册php定义的常量：PHP_VERSION,PHP_OS等；
     6. 解析php.ini：解析完成后所有的php.ini配置保存在configuration_hash哈希表中；
     7. 映射php，zend核心的php.ini配置，根据解析出的php.ini，获取对应的配置值，将最终的配置值插入EG(ini_directives)哈希表中；
     8. 注册用于获取$_GET,$_POST,$_COOKIE,$_SERVER,$_ENV,$_REQUEST,$_FILES变量的handler；
     9. 注册静态编译的扩展：php_register_internal_extensions_func();
     10. 注册动态加载的扩展：php_ini_register_extensions()，将php.ini中配置的扩展加载到php；
     11. 回调各扩展定义的module startup钩子函数（PHP_MINIT_FUNCTION()定义的函数）；
     12. 注册php.ini中禁用的函数，类：disable_functions,disable_classes;
     

- 请求初始化阶段
> 请求处理前每个请求都会经历这个阶段，对于fom而言，是在worker进程accept一个请求且读取，解析完请求数据后的一个阶段，处理函数是php_request_startup。

    1. 激活输出（php_output_activate());
    2. 激活zend引擎(zend_activate()):
         1. 重置垃圾回收器(gc_reset())； 
         2. 初始化编译器（init_compiler()）;
         3. 初始化执行器（init_executor）;
         4. 初始化词法扫描器（startup_scanner()）;
    3. 激活SAPI（sapi_activate()）;
    4. 回调各扩展定义的request startup钩子函数（zend_activate_modules()）;
    
- 执行脚本阶段
> php代码的编译，执行。zend引擎最重要的功能，在编译阶段，php脚本从php源代码到抽象语法树再到opline指令。最终生成opline指令就是zend引擎可以识别的执行指令。然后这些指令会被执行器执行。入口函数为php_execute_script()

    1.  zendy引擎zend_execute_script()方法；
    2. zend_compile_file()方法扫描分析词法语法编译生成opcodes；
        1. Scanning(Lexing) ,将PHP代码转换为语言片段(Tokens)；
        2. Parsing, 将Tokens转换成简单而有意义的表达式:zendparse(),生成一种抽象语法树；
        3. Compilation，将表达式编译成Opocdes；
    3. zend_execute()执行opcodes指令；
    
    
- 请求关闭阶段
> 这个阶段是flush输出内容，发送http应答header头，清理全局变量，关闭编辑器，关闭执行器等。还会回调各扩展的request shutdown钩子函数。入口函数是php_request_shutdown()。

    1. php_call_shutdown_functions()：依次调用通过register_shutdown_function()注册的钩子函数；
    2. zend_call_destructors():通过shutdown_destrunctors()函数清除EG,如果变量有析构函数就调用。
    3. php_output_discard_all()和php_output_end_all()flush所有输出；
    4. zend_deactivate_modules()调用各扩展的request_shutdown函数；
    5. php_output_deactivate():关闭output，发送http应答header头，清理output handlers；
    6. php_free_shutdown_functions()：释放register_shutdown_function函数；
    7. zend_post_deactivate_modules()：销毁全局变量；
    8. zend_deactivate():关闭zend引擎；
    9. shutdown_memory_manager()：关闭内存管理器；
    
    
- 模块关闭阶段
> 这个阶段是SAPI关闭，主要是资料的清理，php各模块的关闭操作，也同样回调各扩展的module shutdown 的钩子函数。入口函数是php_module_shutdown()。

    1. sapi_flush()：
    2. zend_shutdown()：清理持久化符号表，清理module_registry HashTable，调用各扩展的mshutdown清理扩展globals，注销扩展提供的内部函数；
    3. unergister_ini_entries()：清理ini HashTable元素；
    4. zend_ini_global_shutdown()：销毁EG;
    5. php_output_shutdown()：关闭output；
    6. core_globals_dtor()：释放PG;
    
    
   
     
        