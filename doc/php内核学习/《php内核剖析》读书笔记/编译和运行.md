- 解释型语言
1. 编程语言分为编译型语言和解释型语言，编译型语言是在程序运行前通过编译器对编程语言进行翻译成计算机语言的可执行的二进制文件，运行时直接执行程序指令。这种语言如c/c++，java,golang;相反解释型语言是在程序运行时才通过解释器边编译边执行的语言，这种语言也称为脚本语言。php就是这种语言。两种语言相比，编译型语言运行的效率高于解释型语言，相反编译型语言的开发效率低于解释型语言。

- Zend虚拟机（ZendVM）
> php的解释器，负责php的解析和执行。ZendVM预先定义好了大量指令，php代码会在执行时会被解析成这些定义好指令，这种指令最后被机器对应调用机器指令完成执行。
1. 编译器
> 将php代码解释为ZendVM可识别的指令opline，同时生成对应的符号表（函数，类等）。  

    1. opline：ZendVM定义的执行指令，每条指令的编码为opcode。opline的编译是php编译器最核心的操作，也是编译阶段的产物。  
        1. opline指令结构是zend_op。概括的说分为操作对象的操作数和处理动作的opcode。
        2. opcode：指令编码。唯一标识一个指令动作，他是一个运算符，用于决定做什么事情。目前php定义了173(php7：198)条opcode，所有的php语法都是基于这些opcode实现的。（源码文件见zend_vm_opcode.h）
        3. 操作数：操作对象。zend_op中定义三个操作数：op1，op2，result。操作数的结构是znode_op，实际上是个32位整型。并不是每个指令都用到三个操作数，也有可能没有用到操作数。比如：$a = 123,操作数1用来告诉VM变量$a的位置，操作数2用来保存变量值123的位置，执行时ZendVM从操作数获取变量$a和变量值123的存储位置，执行对应的工作。
        4. handler：opcode对应的实际处理函数；
    2. zend_op_array：所有的opline指令集合组成zend_op_array。还保存很多编译生成的关键数据。他是编译器的输出，也是执行器的输入。
    3. zend_execute_data：zendVM执行opcode指令前会根据zend_op_array信息分配一个zend_execute_data结构，用来保存运行时的信息，包括当前执行指令，局部变量，上下文调用信息等。
    4. zend_executor_globals：全局符号表，保存类，函数符号表。
编译过程（zend_execute_script()）：compile_file()进入，zendparse()进行词法/语法分析，zend_compile_top_stmt()解析AST,生成opcodes,再经过pass_two进行一次特殊处理，最后才zend_execute()完成执行。

2. 执行器
> 由指令处理handler与调度器组成。

    1. handler  
        1. 指令处理handler是每条opcode定义的具体处理过程，根据操作数的不同类型，每种opcode可定义25个handler；
        2. zend_vm_handler()定义handler。
    2. 调度器
        1. 负责控制指令的执行，以及执行器的上下文切换，发起handler的执行。
        
3. 执行流程
> zend_execute_data是ZendVM执行过程中非常重要的数据结构，记录运行时信息，分配动态变量内存。在执行流程之前是分配一个zend_execute_data结构。

    1. 分配zend_execute_data：zend_vm_stack_push_call_frame()分配一块用于当前作用域的内存空间（zend_execute_data）。
    2. 初始化zend_execute_data：初始化成员，添加全局变量。
    3. 执行：执行调度器（zend_execute_ex）while循环调用opline指令的handler，然后根据handler的返回决定下一步的动作。
    4. 释放zend_execute_data：执行完成后释放。
    
    
- opcache
> 用于缓存opcodes以提升php性能的zend扩展，开启opcache后，将php的编译函数zend_compile_file替换为persistent_compile_file(),接管php代码的编译过程，首先检查是否有该文件的缓存。
